2장 클래스와 객체
<클래스>
- 한 사람의 "이름"과 "전화번호"는 항상 같이 붙어다녀야 하는 데이터이다.
- 이 두 가지 데이터를 서로 별개의 변수에 저장하면 우리가 이름 데이터를 옮길  때 마다 전화번호 데이터도 따로 옮겨줘야 한다.
- 만약 각 사람에 대해서 이름과 전화번호 뿐만 아니라 주소, 이메일 등 여러 가지 데이터를 저장한다면  이 불편은 더 심해질 것이다.
- 인덱스 메이커 프로그램에서도 "하나의 단어"와 그 단어의 "등장 횟수"는 항상 같이 붙어다녀야 하는 데이터이다.
- 이렇게 서로 관련있는 데이터들을 하나의 단위로 묶어두면 편할 것이다.
- 이것이 클래스라는 개념이 등장하는 가장 기본적인 이유이다.

- 클래스는 결국 하나의 "타입"이다, 마치 int,double등 처럼
- 다만 int,double처럼 Java가 미리 정해놓은 타입이 아니라 사용자가 정의한 새로운 타입이라는 의미에서 "사용자 정의 타입"
     이라고 부르기도 한다.
- int 혹은 double형 변수를 선언하고 사용하는 것처럼 Person1형 변수를 선언하고 사용한다.
  int count = 0;
  Person1 first = new Person1();
  
 <프리미티브 타입과 클래스: 차이점>
 - int 혹은 double 형 변수를 선언하고 사용하는 것처럼 Person1형 변수를 선언하고 사용한다.
   int count = 0;
   -> count라는 이름의 변수가 만들어지고 그 "안"에 정수값 0이 저장된다.
   Person1 first = new Person1();
   -> first라는 이름의 변수가 만들어지지만 그 "안"에 사람 이름과 전화번호가 저장되지는 않는다.
            이름과 전화번호를 저장할 "Person1 객체(object)"는 new 명령으로 따로 만들어야 하고
     first에는 그 객체의 주소(참조)를 저장할 수 있다.
 <클래스와 객체>
 
 Person1 first;
 - first 라는 이름의 변수만을 선언했다면 아직 객체는 생성되지 않고 변수 first만 만들어진다. 이때 이 변수의 값은 null   
 
 first = new Person1();
 - new Person1() 명령에 의해 "Person1 객체"가 만들어지고 first에 그 주소를 저장한다.
 
 first.name = "John"; first.number = "13123132";
 - first가 가리키고 있는 Person1 타입의 객체의 name과 number라는 이름의 필드에 각각 데이터를 저장한다.
 
 
 The rule is very simple.
 모든 프리미티브 타입의 변수는 보통 변수이다.
 즉 변수 자체에 값이 저장된다.
 프리미티브 타입이 아닌 모든 변수는 ""참조변수"" 이다.
 즉 실제 데이터가 저장될 "객체"는 new명령으로 따로 만들어야 하고, 참조변수에는 그 객체의 주소를 저장한다.  
 
 int [] number = new int[8]; 
 이렇게 보면 정수형 배열이라 프리미티브타입이라 생각 할 수 있지만 배열은 프리미티브타입이 아니다. 
 프리미티비 타입의 배열이라고 하더라고 배열의 각 원소가 프리미티브 타입인 것이지 배열 자체가 프리미티브 타입인 것은 아니다.
 따라서 배열의 이름 numbers는 참조변수 (배열원소의 주소를 저장하는)이다.
 배열의 각 칸은 int타입의 프리미티브 변수이다.
int [] number = new int[8];를 수행하는 순간 8칸을 가진 배열이 실제로 만들어지고 그 주소가 참조변수 numbers에 저장된다.
 
 Person1 members = new Person1[8];
 members는 배열의 이름이므로 당연히 참조변수이다.
  배열의 각 칸은 Person1타입이다. 그런데 Person1은 프리미티브 타입이아니다.
  따라서 배열의 각 칸도 참조변수이다.
  즉 이 상태에서 배열의 각 칸에 다음과 같이 바로 이름과 번호를 저장할 수 는 없다.
  members[2].name="john";
  members[2].nunber="31241234"; -> 가능하지 않다.
  
 <값에 의한 호출: 배열>
 호출문:
 bubbleSort(data,count);
 ...
 호출된 매서드:
 public static void bubbleSort(int [] data2, int n){
 for(){
   for(){
     if(){
     }
    }
   }
  }
 1. 호출하는 순간 변수 data의 값이 호출된 메서드의 매개변수 data2로 복사된다.
 2. 그런데 복사된 값은 배열의 주소이다. 그러므로 data와 data2는 실제로는 동일한 배열을 가리키게 된다.
 3. 따라서 배열 data2의 내용을 변경하면 배열 data의 내용도 변경된다.
 즉 배열을 매개변수로 넘겨주고 호출된 매서드에서 배열의 값을 수정하면 원본배열의 값도 수정되는 것은 "값에의한 호출"의 예외가 아니라
 배열의 이름이 참조변수이기 때문에 벌어진 일이다.
 
 < 사각형의 면적 >
 - 평면상에 좌표축에 평행한 n개의 직사각형에 관한 데이터를 입력 받은 후 면적이 작은 것부터 큰 것 순으로 출력하는 프로그램을 작성.
 - 0 1 2 4 / 왼쪽-위쪽 꼭지점의 좌표가 (0,1)이고 너비가 2, 높이가 4
   1 4 7 8
   4 3 12 9
   8 18 11 30
   5 10 6 11
 
 
  < 다항함수 >
 - 다항함수(polynomal)는 항(term)들의 합이며, 항은 계수(coefficient)와 지수(exponent)에 의해서 정의된다. 계수는 0이 아닌 정수이고 지수는 음이 아닌 정수라고 가정한다.
  
 - 프로그램 실행 예
 $ create f      // 다항함수 f=0을 정의한다.
 $ add f 2 3     // f(x)에 2x^3을 더한다. 따라서 f(x)=2x^3 이된다.
 $ add f -1 1    // f(x) = 2x^3 - x 이 된다.
 $ add f 5 0     // f(x) = 2x^3 - x + 5 이 된다.
 $ add f 2 1     // f(x) = 2x^3 - x + 5 + 2x = 2x^3 + x + 5 이 된다.
 $ calc f 2      // x=2 일때 다항함수의 값, 즉 f(2) =23을 계산하여 출력한다.
 23
 $ print f       // 차수에 관한 내림차순으로 정렬하여 다음과 같이 출력한다.
 2X^3 + x + 5    // 동일한 차수의 항은 하나로 합쳐져야 한다.
 $ create g      // 다른 다항 함수 g를 정의한다.
 ....
 exit
   