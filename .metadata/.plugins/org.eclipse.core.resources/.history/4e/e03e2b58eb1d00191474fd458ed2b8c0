2장 클래스와 객체
<클래스>
- 한 사람의 "이름"과 "전화번호"는 항상 같이 붙어다녀야 하는 데이터이다.
- 이 두 가지 데이터를 서로 별개의 변수에 저장하면 우리가 이름 데이터를 옮길  때 마다 전화번호 데이터도 따로 옮겨줘야 한다.
- 만약 각 사람에 대해서 이름과 전화번호 뿐만 아니라 주소, 이메일 등 여러 가지 데이터를 저장한다면  이 불편은 더 심해질 것이다.
- 인덱스 메이커 프로그램에서도 "하나의 단어"와 그 단어의 "등장 횟수"는 항상 같이 붙어다녀야 하는 데이터이다.
- 이렇게 서로 관련있는 데이터들을 하나의 단위로 묶어두면 편할 것이다.
- 이것이 클래스라는 개념이 등장하는 가장 기본적인 이유이다.

- 클래스는 결국 하나의 "타입"이다, 마치 int,double등 처럼
- 다만 int,double처럼 Java가 미리 정해놓은 타입이 아니라 사용자가 정의한 새로운 타입이라는 의미에서 "사용자 정의 타입"
     이라고 부르기도 한다.
- int 혹은 double형 변수를 선언하고 사용하는 것처럼 Person1형 변수를 선언하고 사용한다.
  int count = 0;
  Person1 first = new Person1();
  
 <프리미티브 타입과 클래스: 차이점>
 - int 혹은 double 형 변수를 선언하고 사용하는 것처럼 Person1형 변수를 선언하고 사용한다.
   int count = 0;
   -> count라는 이름의 변수가 만들어지고 그 "안"에 정수값 0이 저장된다.
   Person1 first = new Person1();
   -> first라는 이름의 변수가 만들어지지만 그 "안"에 사람 이름과 전화번호가 저장되지는 않는다.
            이름과 전화번호를 저장할 "Person1 객체(object)"는 new 명령으로 따로 만들어야 하고
     first에는 그 객체의 주소(참조)를 저장할 수 있다.
 <클래스와 객체>
 
 Person1 first;
 - first 라는 이름의 변수만을 선언했다면 아직 객체는 생성되지 않고 변수 first만 만들어진다. 이때 이 변수의 값은 null   
 
 first = new Person1();
 - new Person1() 명령에 의해 "Person1 객체"가 만들어지고 first에 그 주소를 저장한다.
 
 first.name = "John"; first.number = "13123132";
 - first가 가리키고 있는 Person1 타입의 객체의 name과 number라는 이름의 필드에 각각 데이터를 저장한다.
 
 
 The rule is very simple.
 모든 프리미티브 타입의 변수는 보통 변수이다.
 즉 변수 자체에 값이 저장된다.
 프리미티브 타입이 아닌 모든 변수는 ""참조변수"" 이다.
 즉 실제 데이터가 저장될 "객체"는 new명령으로 따로 만들어야 하고, 참조변수에는 그 객체의 주소를 저장한다.  
 
 int [] number = new int[8]; 
 이렇게 보면 정수형 배열이라 프리미티브타입이라 생각 할 수 있지만 배열은 프리미티브타입이 아니다. 
 프리미티비 타입의 배열이라고 하더라고 배열의 각 원소가 프리미티브 타입인 것이지 배열 자체가 프리미티브 타입인 것은 아니다.
 따라서 배열의 이름 numbers는 참조변수 (배열원소의 주소를 저장하는)이다.
 배열의 각 칸은 int타입의 프리미티브 변수이다.
int [] number = new int[8];를 수행하는 순간 8칸을 가진 배열이 실제로 만들어지고 그 주소가 참조변수 numbers에 저장된다.
 
 Person1 members = new Person1[8];
 members는 배열의 이름이므로 당연히 참조변수이다.
  배열의 각 칸은 Person1타입이다. 그런데 Person1은 프리미티브 타입이아니다.
  따라서 배열의 각 칸도 참조변수이다.
  즉 이 상태에서 배열의 각 칸에 다음과 같이 바로 이름과 번호를 저장할 수 는 없다.
  members[2].name="john";
  members[2].nunber="31241234"; -> 가능하지 않다.
  
 <값에 의한 호출: 배열>
 호출문:
 bubbleSort(data,count);
 ...
 호출된 매서드:
 public static void bubbleSort(int [] data2, int n){
 for(){
   for(){
     if(){
     }
    }
   }
  }
 1. 호출하는 순간 변수 data의 값이 호출된 메서드의 매개변수 data2로 복사된다.
 2. 그런데 복사된 값은 배열의 주소이다. 그러므로 data와 data2는 실제로는 동일한 배열을 가리키게 된다.
 3. 따라서 배열 data2의 내용을 변경하면 배열 data의 내용도 변경된다.
 즉 배열을 매개변수로 넘겨주고 호출된 매서드에서 배열의 값을 수정하면 원본배열의 값도 수정되는 것은 "값에의한 호출"의 예외가 아니라
 배열의 이름이 참조변수이기 때문에 벌어진 일이다.
 
 < 사각형의 면적 >
 - 평면상에 좌표축에 평행한 n개의 직사각형에 관한 데이터를 입력 받은 후 면적이 작은 것부터 큰 것 순으로 출력하는 프로그램을 작성.
 - 0 1 2 4 / 왼쪽-위쪽 꼭지점의 좌표가 (0,1)이고 너비가 2, 높이가 4
   1 4 7 8
   4 3 12 9
   8 18 11 30
   5 10 6 11
 
 
  < 다항함수 >
 - 다항함수(polynomal)는 항(term)들의 합이며, 항은 계수(coefficient)와 지수(exponent)에 의해서 정의된다. 계수는 0이 아닌 정수이고 지수는 음이 아닌 정수라고 가정한다.
  
 - 프로그램 실행 예
 $ create f      // 다항함수 f=0을 정의한다.
 $ add f 2 3     // f(x)에 2x^3을 더한다. 따라서 f(x)=2x^3 이된다.
 $ add f -1 1    // f(x) = 2x^3 - x 이 된다.
 $ add f 5 0     // f(x) = 2x^3 - x + 5 이 된다.
 $ add f 2 1     // f(x) = 2x^3 - x + 5 + 2x = 2x^3 + x + 5 이 된다.
 $ calc f 2      // x=2 일때 다항함수의 값, 즉 f(2) =23을 계산하여 출력한다.
 23
 $ print f       // 차수에 관한 내림차순으로 정렬하여 다음과 같이 출력한다.
 2X^3 + x + 5    // 동일한 차수의 항은 하나로 합쳐져야 한다.
 $ create g      // 다른 다항 함수 g를 정의한다.
 ....
 exit
 
 
 <메서드와 생성자>
- 클래스는 서로 관련있는 데이터들을 하나의 단위로 묶어두기 위한 것이다.
- 하지만 이것이 전부가 아니다.
- 서로 관련있는 데이터들 뿐 아니라, 그 데이터와 관련이 깊은 메서드도 함께 묶어 둘 수 있다.
- 이렇게 함으로써 코드의 응집도를 높이고 결합도를 낮출 수 있다. -> 프로그램이 단순해질 수 있다.
    다른 클래스와의 상호의존성이 낮아지기 때문에 하나의 클래스를 변경해도 다른 클래스에 영향을 미치지 않는다.

 <객체란?>
 - 객체지향 프로그래밍에서 객체란 "데이터" + "메서드"이다. 데이터는 객체의 "정적 속성"을 표현하며, 메서드는 객체의
  "기능 (동적 속성)"을 표현한다.
      하나의 항(Term)은 "계수와 차수"라는 정적 속성과 "x의 값을 주면 자신의 값을 계산해준다", "화면에 출력해 준다"등의 기능을 가진다.
      
 <생성자>
- 클래스 안에 그 클래스와 동일한 이름을 가지며 return 타입이 없는 특별한 메서드를 둘 수 있다. 이것을 생성자(constructor)라고 한다. 
- 생성자는 new명령으로 객체가 생성될 때 자동으로 실행된다. 주 목적은 객체의 데이터 필드의 값을 초기화하는 것이다.  
  생성자가 없는 Term의 경우 다음과 같이 객체를 생성한 후 따로 데이터 멤버의 값을 초기화하였다.
  Term2 t = new Term2();
  t.coef = 3;
  t.expo = 2;
  
   생성자가 있는 경우 다음과 같이 객체의 생성과 초기화를 한번에 할 수 있다.
  Term3 t2 = new Term3(3,2);
  
  --> 생성자를 적절히 사용하여 코드의 가독성도 높일 수 있다.
  
  생성자가 반드시 매개변수를 받아야하는 것은 아니다. 생성자는 객체에게 필요한 초기화 작업을 하기에 적절한 장소이다.
  
 <다각형과 점>
 
 - 입력으로 하나의 직교 다각형(모든 변이 x-축 혹은 y-축과 평행한 다각형)과 또 하나의 점 p가 주어질 때 그 점이 다각형의 내부에 있는지
 외부에 있는지 판단하는 프로그램을 작성하라.
 - 내부/외부 검사
    : 점에서 시작하여 한 방향으로 무한히 뻗어가는 아무 직선이나 하나 그어서 그것이 다각형의 변과 짝수 번 교차하면 외부, 홀수 번 교차하면 내부에 있다. 
    (문제를 조금 단순화하기 위해서 여기서는 점p는 다각형의 경계상에 있지 않고, 또한 다각형에는 p와 동일한 x혹은 y좌표를 가진 꼭지점은 없다고 가정한다.
           꼭지점의 좌표값은 모두 짝수, 검사할 점 p의 좌표값은 홀수로 가정한다.)
           
 2-3장 
 <클래스와 객체>
 - 클래스는 타입이다. 집이 아니라 집의 설계도이다. 즉 실체가 아니다.
 - 따라서 클래스의 데이터 필드에 데이터를 저장할 수는 없고, 클래스의 멤버 메서드를 실행할 수 도 없다. 왜냐하면 실체가 아니므로!
 - new 명령으로 해당 클래스 타입의 객체를 만든 후 , 그 객체에 데이터를 저장하고, 그 객체의 멤버 메서드를 실행하는 것이다.
 - 여기에는 하나의 예외가 존재하는데 그것이 static 멤버이다.
 - static 멤버는 클래스 안에 실재로 존재하며 객체에는 존재하지 않는다.
 - static 멤버는 class 멤버이고 ,       클래스 안에 존재
 - non-static 멤버는 object 멤버이다.  객체안에 존재
 
 <Qeustions>
 - 왜 main 메서드는 반드시 static이어야 하는가?
   : 자바에서 프로그램은(무조건) 클래스들의 집합이다. 클래스 외부에 어떤것도 존재할 수 없다. 클래스 안에 어떤 메소드를 실행하려면
     객체를 생성하고 그 객체를 실행해야한다. 그래서  main함수가 꼭 필요함 (프로그램의 시작점이라 할 수 있다.) 그렇기 떄문에 반드시 static집합이어야 한다.
 - 왜 static 메서드에서 같은 클래스의 non-static 멤버를 엑세스 할 수 없는가? 
   : (메인함수가 속해있는 클래스에는 모든 함수를 static으로 한 이유는?) static은 클래스안에 속해잇는 멤버이고, non-static은 오브젝트안에 속해있는 멤버이기 때문에 엑세스 불가
 - 다른 클래스에 속한 static 멤버는 어떻게 엑세스하는가?
   : 
 - static 메서드/필드의 용도는?